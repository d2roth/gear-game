<!DOCTYPE html>
<html>
<head>
  <title>Gear Game</title>
  <script src="./node_modules/pixi.js/dist/pixi.js"></script>
</head>
<body>
<script>

  function placePiece(event){
    console.log( event );
    sprite.scale.x *= 1.25;
    sprite.scale.y *= 1.25;
  }

  let app = new PIXI.Application({
    width: 800,
    height: 800,
    antialias: true,
  });
  document.body.appendChild(app.view);

  let notches = 8,                      // num. of notches
    radiusO   = 55,                     // outer radius
    radiusI   = 40,                     // inner radius
    taperO    = 60,                     // outer taper %
    taperI    = 50,                     // inner taper %

    // pre-calculate values for loop
    pi2     = 2 * Math.PI,            // cache 2xPI (360deg)
    angle   = pi2 / (notches * 2),    // angle between notches
    taperAI = angle * taperI * 0.005, // inner taper offset (100% = half notch)
    taperAO = angle * taperO * 0.005, // outer taper offset

    // Calculate the gears
    rows        = 5,
    pegSize     = radiusI/2,
    fudgeAmount = 1, // Amount to fudge so the cogs don't actually touch
    offsetX     = radiusO - (radiusO - radiusI)/2 + fudgeAmount, // outer - length of tooth + fudge amount
    offsetY     = offsetX * Math.sqrt(3);


  // Author: user1693593
  // Source: https://stackoverflow.com/a/23532468
  function buildCog(peg){
    let cx     = peg.x,
        cy     = peg.y,
        points = [],
        cog    = new PIXI.Graphics(),
        a      = angle,
        toggle = false;
    // cog.beginFill(Math.floor(Math.random()*16777215).toString(16));
    cog.lineStyle(1, 0xFF0000);
    cog.beginFill(0xFF0000);

    // loop
    for (; a <= pi2; a += angle) {
        // draw inner to outer line
        if (toggle) {
            points.push(cx + radiusI * Math.cos(a - taperAI));
            points.push(cy + radiusI * Math.sin(a - taperAI));
            points.push(cx + radiusO * Math.cos(a + taperAO));
            points.push(cy + radiusO * Math.sin(a + taperAO));
        }

        // draw outer to inner line
        else {
            points.push(cx + radiusO * Math.cos(a - taperAO));
            points.push(cy + radiusO * Math.sin(a - taperAO));
            points.push(cx + radiusI * Math.cos(a + taperAI));
            points.push(cy + radiusI * Math.sin(a + taperAI));
        }

        // switch level
        toggle = !toggle;
    }

    // Draw one more line to close the final line
    if (toggle) {
        points.push(cx + radiusI * Math.cos(a - taperAI));
        points.push(cy + radiusI * Math.sin(a - taperAI));
        points.push(cx + radiusO * Math.cos(a + taperAO));
        points.push(cy + radiusO * Math.sin(a + taperAO));
    }

    // draw outer to inner line
    else {
        points.push(cx + radiusO * Math.cos(a - taperAO));
        points.push(cy + radiusO * Math.sin(a - taperAO));
        points.push(cx + radiusI * Math.cos(a + taperAI));
        points.push(cy + radiusI * Math.sin(a + taperAI));
    }

    cog.drawPolygon(points);
    cog.pivot.x = cx;
    cog.pivot.y = cy;
    cog.zIndex = -10;
    cog.x = cx;
    cog.y = cy;
    return cog;
  }

  let centerX = app.view.width/2,
      centerY = offsetY;

  let pegs = [];
  let reference = new Map();
  for( row = 0; row <= rows; row++ ){
    let rowStartOffset = centerX-((offsetX*(row-1)));
    for( col = 0; col<row; col++ ){
      let bx = ( col * 2 ) * offsetX;
      let by = row * offsetY;
      let peg = {
        index: pegs.length,
        row: row,
        col: col,
        x: rowStartOffset + bx,
        y:by,
        edges: [],
        filled: false,
      };
      pegs.push(peg);
      reference.set(`${row}-${col}`, peg)
    }
  }

  pegs.forEach(peg => {
    [
      // Previous row
      [-1,-1],
      [-1, 0],
      [-1, 1],
      // Same row
      [ 0,-1],
      // [ 0, 0],
      [ 0, 1],

      // Next Row
      [ 1,-1],
      [ 1, 0],
      [ 1, 1],
    ].forEach( relativePosition => {
      let relatedPeg = `${peg.row+relativePosition[0]}-${peg.col+relativePosition[1]}`;
      if( reference.has( relatedPeg ) ){
        peg.edges.push(reference.get(relatedPeg));
      }
    })
  })

  let cogs = [];
  for( i = 0; i < 5; i++){
    let cx = (radiusO*2 - radiusI/2)*i;
    let cy = radiusO;
    cx = pegs[i].x;
    cy = pegs[i].y;
    // Get the diameter and then subtract the difference for the inner radius
    let c = buildCog(pegs[i]);
    c.rotation = 0;
    cogs.push(c);
    app.stage.addChild(c);
    pegs[i].filled = true;
    pegs[i].cog = c;
  }

  pegs.forEach( p => {
    let pegGraphics = new PIXI.Graphics();
        pegGraphics.beginFill(0xFFFFFF)
                   .lineStyle(1, 0xFF0000);
        pegGraphics.interactive = true;
        pegGraphics.cursor = "pointer";
        pegGraphics.buttonMode = true;
        pegGraphics.on( "pointerdown", (event) => {
          if( !p.cog ){
            let c = buildCog(p);
            c.rotation = 0;
            cogs.push(c);
            p.cog = c;
            app.stage.addChild(c);
          }
          powered.push(p.index)
          console.log( p,event, pegGraphics);
        })
    pegGraphics.drawCircle(p.x, p.y, pegSize);
    app.stage.addChild(pegGraphics);

    // Add the text to tell what our rotation is for debugging purposes
    let pegText = new PIXI.Text(0, new PIXI.TextStyle( {
      fontStyle: 'italic',
      fontWeight: 'bold',
      fill: ['#ffffff', '#00ff99'], // gradient
      stroke: '#4a1850',
      strokeThickness: 5,
      dropShadow: true,
      dropShadowColor: '#000000',
      dropShadowBlur: 4,
      dropShadowAngle: Math.PI / 6,
      dropShadowDistance: 6,
      wordWrap: true,
      wordWrapWidth: 440,
      lineJoin: 'round',
      // background: '0x00FF00',
    }));


    pegText.x = p.x;
    pegText.y = p.y;
    p.pegText = pegText;
    app.stage.addChild(pegText);
  })

  // // Add interactivity
  // sprite.interactive = true;
  // sprite.cursor = "pointer";
  // sprite.buttonMode = true;
  // sprite.on('pointerdown', (event) => {
  //   console.log( "You pointerdown'ed me")
  //   placePiece(event)
  // });


  let elapsed = 0.0;
  // app.stage.pivot.x = app.stage.width / 2;
  // app.stage.pivot.y = app.stage.height / 2;

  // sprite.anchor.set(0.5);

// Find out what interactive object lies at [100, 50]
// let globalPt = new PIXI.Point(100,50);
// let obj = app.renderer.plugins.interaction.hitTest(globalPt);

  let speed = 0.02;
  let powered = [];//[0,2,3];
  let maxRotation = 2 * Math.PI;
  // Build out the game logic here
  app.ticker.add( (delta) => {
    if(!powered.length)
      return;

    elapsed += delta;
    
    let clockwise = false;
    powered.forEach( i => {
      // console.log( pegs[i], cogs[i] );
      cog = pegs[i].cog;

      if( Math.abs( cog.rotation ) >= maxRotation )
        cog.rotation = 0;

      if( clockwise )
        cog.rotation += speed * delta;
      else
        cog.rotation -= speed * delta;
      pegs[i].pegText.text = Math.round( cog.rotation *100 )/100;
      clockwise = !clockwise;
    })
    // cogs.forEach( (cog, i) => {
    //   if( clockwise )
    //     cog.rotation += speed * delta;
    //   else
    //     cog.rotation -= speed * delta;
    //   clockwise = !clockwise;
    // })
  })

   /**
   * @source: https://sodocumentation.net/html5-canvas/topic/5017/collisions-and-intersections#are-2-polygons-colliding---both-concave-and-convex-polys-are-allowed-
   */
  // polygon objects are an array of vertices forming the polygon
  //     var polygon1=[{x:100,y:100},{x:150,y:150},{x:50,y:150},...];
  // The polygons can be both concave and convex
  // return true if the 2 polygons are colliding 

  function polygonsCollide(p1,p2){
      // turn vertices into line points
      var lines1=verticesToLinePoints(p1);
      var lines2=verticesToLinePoints(p2);
      // test each poly1 side vs each poly2 side for intersections
      for(i=0; i<lines1.length; i++){
      for(j=0; j<lines2.length; j++){
          // test if sides intersect
          var p0=lines1[i][0];
          var p1=lines1[i][1];
          var p2=lines2[j][0];
          var p3=lines2[j][1];
          // found an intersection -- polys do collide
          if(lineSegmentsCollide(p0,p1,p2,p3)){return(true);}
      }}
      // none of the sides intersect
      return(false);
  }
  // helper: turn vertices into line points
  function verticesToLinePoints(p){
      // make sure polys are self-closing
      if(!(p[0].x==p[p.length-1].x && p[0].y==p[p.length-1].y)){
          p.push({x:p[0].x,y:p[0].y});
      }
      var lines=[];
      for(var i=1;i<p.length;i++){
          var p1=p[i-1];
          var p2=p[i];
          lines.push([ 
              {x:p1.x, y:p1.y},
              {x:p2.x, y:p2.y}
          ]);
      }
      return(lines);
  }
  // helper: test line intersections
  // point object: {x:, y:}
  // p0 & p1 form one segment, p2 & p3 form the second segment
  // Get interseting point of 2 line segments (if any)
  // Attribution: http://paulbourke.net/geometry/pointlineplane/
  function lineSegmentsCollide(p0,p1,p2,p3) {
      var unknownA = (p3.x-p2.x) * (p0.y-p2.y) - (p3.y-p2.y) * (p0.x-p2.x);
      var unknownB = (p1.x-p0.x) * (p0.y-p2.y) - (p1.y-p0.y) * (p0.x-p2.x);
      var denominator  = (p3.y-p2.y) * (p1.x-p0.x) - (p3.x-p2.x) * (p1.y-p0.y);        

      // Test if Coincident
      // If the denominator and numerator for the ua and ub are 0
      //    then the two lines are coincident.    
      if(unknownA==0 && unknownB==0 && denominator==0){return(null);}

      // Test if Parallel 
      // If the denominator for the equations for ua and ub is 0
      //     then the two lines are parallel. 
      if (denominator == 0) return null;

      // test if line segments are colliding
      unknownA /= denominator;
      unknownB /= denominator;
      var isIntersecting=(unknownA>=0 && unknownA<=1 && unknownB>=0 && unknownB<=1)

      return(isIntersecting);
  }
</script>
</body>
</html>